# AI Agent Framework - Cursor Rules
# These rules help Cursor AI understand the project structure and coding conventions

# Project Description
This is an AI Agent Framework for building and orchestrating intelligent agents
with memory, tool integration, and real-time communication capabilities.

# File Organization
src/core/         # Core components (Agent, Orchestrator)
src/llm/          # LLM provider implementations
src/memory/       # Memory systems (buffer, long-term)
src/tools/        # Tool system and implementations
src/api/          # API server and WebSocket implementation
src/web/          # Web dashboard
src/utils/        # Utility functions and helpers
tests/            # Test files

# Coding Style
- Follow PEP 8 guidelines
- Use 4 spaces for indentation
- Maximum line length of 79 characters
- Use Black for formatting
- Use type hints consistently
- Use docstrings in Google style format
- Organize imports: stdlib, third-party, local

# Naming Conventions
- Classes: PascalCase
- Functions and variables: snake_case
- Constants: UPPER_SNAKE_CASE
- Private attributes: _leading_underscore
- Use descriptive names that reflect purpose

# Import Conventions
from typing import Dict, List, Optional, Any  # Import specific types
import standard_library                       # Standard library imports first
import third_party_library                    # Third party imports second
from src.module import local_import           # Local imports last

# Common Patterns
- Use dataclasses for data containers
- Use async/await for asynchronous code
- Use context managers for resource management
- Prefer composition over inheritance
- Create base classes for extensible components
- Use dependency injection for flexibility

# Error Handling
- Use specific exception types
- Handle exceptions at appropriate levels
- Log exceptions with context
- Provide meaningful error messages

# Documentation
- Document all public APIs
- Include examples in docstrings
- Explain parameters and return values
- Document exceptions that might be raised

# Testing
- Write unit tests for all components
- Use pytest for testing
- Mock external dependencies
- Test happy path and error cases

# WebSocket Message Format
- All messages are JSON serializable
- Include "type" field in all messages
- Handle different message types appropriately
- Implement proper error handling

# Modern Control Protocol (MCP)
- Follow the MCP specification for agent communication
- Properly serialize and deserialize MCP messages
- Handle tool calls and responses according to MCP

# Memory Systems
- Use FAISS for short-term buffer memory
- Use PostgreSQL with pgvector for long-term memory
- Implement proper memory persistence
- Handle context length limits

# Tool Integration
- Implement the BaseTool interface for new tools
- Register tools with the ToolRegistry
- Handle tool execution errors
- Return standardized tool results

# Component Examples
## Agent Creation
```python
from src.core.orchestrator import Orchestrator
from src.llm.openai import OpenAILLM
from src.memory.buffer import BufferMemory

orchestrator = Orchestrator()
orchestrator.create_agent(
    agent_id="assistant",
    llm=OpenAILLM(model="gpt-4o"),
    buffer_memory=BufferMemory(),
    system_message="You are a helpful AI assistant."
)
```

## Tool Creation
```python
from src.tools.base import BaseTool
from typing import Any, Dict

class CustomTool(BaseTool):
    name = "custom_tool"
    description = "This tool performs a custom operation."

    def execute(self, **kwargs: Any) -> Dict[str, Any]:
        # Implementation here
        return {
            "success": True,
            "result": "Operation completed"
        }
```

## WebSocket Handling
```python
# Client sends message
{
    "type": "chat",
    "message": "Hello, what can you help me with today?"
}

# Server sends response
{
    "type": "message",
    "content": "I can help you with various tasks..."
}
```
