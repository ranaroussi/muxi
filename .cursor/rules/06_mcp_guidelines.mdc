---
description:
globs:
alwaysApply: false
---
# MCP Implementation Guidelines

> The MUXI framework now exclusively uses MCP servers for all specialized capabilities.
>
> **NEW UPDATE**: The MCP integration has been completely refactored with a centralized MCPService
> singleton pattern for thread-safety and consistent management of all MCP server connections.

## Centralized MCP Service Architecture

- Always use the MCPService singleton for all MCP server interactions
- Access the service through the orchestrator: `await orchestrator.get_mcp_service()`
- Never create multiple instances of MCPService - use the singleton pattern
- The singleton ensures thread-safe operations with proper locking
- MCPService handles connection management, tool parsing, and invocation
- Configurable timeouts at multiple levels:
  - Global default timeout in MCPService
  - Per-agent timeout when connecting to MCP servers
  - Per-request timeout for individual tool invocations

Example usage:
```python
# Get the shared MCPService instance
mcp_service = await orchestrator.get_mcp_service()

# Connect to an MCP server through an agent
await agent.connect_mcp_server(
    name="weather",
    url="http://localhost:5001",
    credentials={"api_key": "your_api_key"},
    timeout=30  # 30-second timeout for this server
)

# Use MCPService directly for advanced use cases
tool_result = await mcp_service.invoke_tool(
    server_id="weather",
    tool_name="get_weather",
    params={"location": "New York"},
    timeout=10  # 10-second timeout for this specific invocation
)
```

## Message Format
- Follow the official MCP specification for message formats
- Properly serialize and deserialize MCP messages
- Include required fields in all messages
- Use consistent naming conventions for custom message types
- Validate message format before processing
- Handle malformed messages gracefully
- Implement proper error responses
- Use appropriate content types
- Include message IDs for tracking and correlation
- Properly handle different versions of the protocol
- Support streaming responses when appropriate
- Document any extensions to the standard protocol

## MCP Server Integration
- MUXI exclusively uses MCP servers for specialized capabilities (no direct tool calls)
- Use MCPService singleton for all MCP server interactions
- Register MCP servers with unique server_id for consistent identification
- Include detailed MCP server descriptions
- Handle MCP server execution errors gracefully
- Return standardized MCP server results
- Include execution metadata in responses
- Implement timeout handling for long-running MCP server operations
- Support parallel MCP server execution when appropriate
- Properly handle MCP server authentication and authorization
- Log all MCP server calls for debugging and audit
- Include rate limiting for resource-intensive MCP servers
- Implement proper error messages for MCP server failures
- Use thread-safe tool invocation with locks for concurrent access

## LLM Integration
- Properly format messages for different LLM providers
- Handle provider-specific extensions
- Implement fallback mechanisms for provider outages
- Properly handle streaming responses
- Process tool call requests from LLMs using ToolParser
- Format MCP server results for LLM consumption
- Handle context limitations appropriately
- Implement appropriate retry logic
- Monitor token usage and implement limits
- Handle provider rate limits gracefully
- Process and validate LLM responses
- Support different model capabilities

## Security
- Validate all inputs
- Implement proper authentication for MCP server access
- Limit MCP server capabilities based on user permissions
- Sanitize MCP server inputs and outputs
- Implement proper error handling that doesn't leak information
- Log security-relevant events
- Handle sensitive information appropriately
- Implement timeouts for all external calls
- Validate message integrity
- Use secure communication channels
- Implement proper access control for different MCP servers
- Monitor for abuse patterns

## External MCP Servers
- Use MCPService for connection management
- Handle reconnection automatically
- Implement proper error handling for server errors
- Support authentication
- Make credentials optional for MCP servers that don't require them
- Validate server responses
- Implement timeout handling
- Support MCP server discovery
- Log all external server interactions
- Implement circuit breakers for fault tolerance
- Monitor server health
- Handle version compatibility
- Document server requirements and capabilities

## Testing
- Test happy path scenarios for all MCP servers
- Test error conditions and failures
- Implement integration tests with actual LLM providers
- Test with mock LLMs for predictable results
- Validate message formats
- Test timeout and cancellation handling
- Test authentication and authorization
- Include MCP tests in CI/CD pipeline
- Test rate limiting
- Implement contract testing
- Test with different LLM providers
- Use representative test data
- Test MCPService thread safety with concurrent access patterns

## Docker Integration
- Package MCP servers in containerized environments
- Use consistent port mapping for MCP servers
- Implement proper health checks
- Support dynamic configuration through environment variables
- Implement proper logging for containerized environments
- Support container orchestration
- Provide clear documentation for container configuration
- Implement proper shutdown handling
- Support service discovery
- Optimize container size and performance
- Support horizontal scaling
- Implement resource constraints

## Transport Implementation
- Implement the Transport Factory pattern for managing different transport types
- Support HTTP+SSE transport for web-based MCP servers (via url parameter)
- Support Command-line transport for local executable MCP servers (via command parameter)
- Use distinct parameters (url or command) to clearly indicate server type
- Implement proper connection lifecycle management (connect, send, receive, disconnect)
- Handle transport-specific error conditions
- Abstract transport details from higher-level code
- Provide consistent API across different transport types
- Test each transport implementation individually
- Document transport-specific requirements and limitations
- Support secure communication for each transport type
- Implement proper resource cleanup for each transport

## Reconnection and Resilience
- Implement reconnection with exponential backoff
- Add jitter to backoff calculations to prevent thundering herd
- Track and expose reconnection statistics
- Implement configurable retry policies
- Handle temporary disconnections gracefully
- Preserve state across reconnections when possible
- Implement proper cancellation support for in-progress operations
- Log detailed diagnostic information for connection failures
- Implement circuit breakers for persistent failures
- Support graceful degradation when servers are unavailable
- Provide clear error messages for connection issues
- Test reconnection behavior thoroughly

## SDK Integration
- Use the official MCP Python SDK (version >=1.4.1)
- Follow SDK best practices for message handling
- Properly handle SDK version compatibility
- Contribute improvements back to the SDK when appropriate
- Document SDK integration requirements
- Implement proper error handling for SDK-related issues
- Test with different SDK versions
- Keep SDK dependencies updated
- Handle breaking changes in SDK appropriately
- Document any extensions or custom implementations
- Properly initialize SDK components
- Handle SDK lifecycle appropriately

## Performance Optimization
- Profile and optimize the transport layer
- Implement connection pooling for HTTP transport
- Optimize message serialization and deserialization
- Minimize latency overhead
- Handle streaming responses efficiently
- Optimize resource usage
- Implement appropriate caching mechanisms
- Monitor and log performance metrics
- Implement performance testing
- Document performance characteristics
- Optimize for different deployment scenarios
- Balance reliability and performance

## Thread Safety and Concurrency
- Always use the MCPService singleton to ensure thread-safe operations
- Utilize async locks for critical sections to prevent race conditions
- Implement proper async/await patterns throughout the MCP implementation
- Ensure all shared state is properly protected
- Handle concurrent MCP server requests appropriately
- Test with multiple concurrent clients to verify thread safety
- Implement proper cleanup of resources in all code paths
- Use thread-safe collections for shared data structures
- Document any concurrency limitations or requirements
- Implement proper cancellation support that respects thread safety
- Ensure consistent state even with concurrent modifications
